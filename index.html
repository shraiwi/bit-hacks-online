<!doctype html>

<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Bit Hacks!</title>

    <link rel="stylesheet" href="css/style.css">

    <script src="src/binary-shifter.js"></script>
</head>

<body>
    <!-- Player -->

    <div class="floating-video">
        <div class="floating-video-container">
            <video 
                onclick="this.paused ? this.play() : this.pause();"
                ondblclick="this.currentTime = 0.0"
                onplay="this.style.opacity = 1.0"
                onended="this.style.opacity = 0.0">
            </video>
        </div>
        <script>
            const video = document.querySelector("div.floating-video-container video");

            video.sources = [
                "video/0_what_is_binary.webm",
                "video/1_counting.webm",
            ];

            video.playSection = (n) => {
                video.src = video.sources[n];
                video.oncanplay = () => video.play();
            }
        </script>
    </div>


    <!-- Bit Hacks! -->
    <div class="chunk">
        <h1>Bit Hacks!</h1>
        <p>This is a primer on binary, numbering systems, and how we can leverage the properties of the binary numbering
            system to do some really cool math (to optimize computers)!</p>
        <p>This entire website was hand-coded from scratch and with a lot of love. I hope you learn something!</p>
        <p>- Shraiwi :D</p>

        <p>P.S. Most of the interactive content on this website doesn't
            work with touchscreens yet. Please use a desktop web browser and mouse.</p>
    </div>

    <div class="chunk hr">
        <h1>Getting up to speed on binary</h1>
    </div>

    <div class="chunk">
        <label for="1">
            <h1>What is binary?</h1>
        </label>
        <input id="1" type="checkbox">

        <div class="content">
            <button 
                class="icon play"
                onclick="video.playSection(0)"
            >
                play_arrow
            </button>
            <p>The top definition of binary on Google is:</p>
            <p><em>relating to, composed of, or involving two things.</em></p>
            <p>Here are some examples of binary pairs:</p>
            <ul>
                <li>Yes and no</li>
                <li>On and off</li>
                <li>True and false</li>

            </ul>
            <p>So now that we know the definition of <em>the word</em> binary, what is binary within the context of
                computers?</p>
            <p>Well, binary is a base-two numbering system. In plain English, that means that each digit of a binary
                number
                is… well… binary. It can have one of <em>two</em> possible values: one or zero. This is opposed to the
                most
                common numbering system, decimal, whose digits can have only one of <em>ten</em> possible values.</p>
            <p>When trying to understand binary, it’s important to discern between numbers and values. </p>
            <p>A number is a representation of a value.</p>
            <p>For example, “5” is not a value. It is a number, which represents a value. This value can also be
                represented
                by:</p>
            <ul>
                <li>The word “five”</li>
                <li>The number of fingers on one human hand</li>
                <li>The binary number 0101</li>
                <li>etc.</li>

            </ul>
            <p>Since there’s no real-world object that <em>is</em> 5, humans have come up with standardized systems that
                can
                <em>represent</em> the value 5.
            </p>
            <p>Binary is an example of such a system.</p>
            <p>So how does it work? Let’s try to understand by figuring out how to count.</p>
        </div>
    </div>

    <!-- How to count -->
    <div class="chunk">
        <label for="2">
            <h1>How to count</h1>
        </label>
        <input id="2" type="checkbox">

        <div class="content">
            <button 
                class="icon play"
                onclick="video.playSection(1)"
            >
                play_arrow
            </button>
            <p>You&#39;re probably thinking, </p>
            <p><em>&quot;Uhm. I think I know how to count...&quot;</em></p>
            <p>..And you&#39;d be right.</p>
            <p>But how does counting logically work? If we can figure that out, we use those rules to increment a binary
                number.</p>
            <p>Let&#39;s start by counting from zero:</p>
            <p>0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ?</p>
            <p>Obviously, next number is 10, but why is it 10? Well, the reason becomes clearer when we count with
                numbers
                formatted like this:</p>
            <p>00, 01, 02, 03, 04, 05, 06, 07, 08, 09, <strong>10</strong></p>
            <p>Although this represents the same sequence, we now get an inkling as to how the number system works. </p>
            <p>Firstly, when we are incrementing the number as a whole, we are actually incrementing the rightmost
                digit.
                When we increment a digit at its maximum value, we simply increment the digit to the left of it and
                reset
                the current digit&#39;s value. Keep in mind that we apply the same rules when we increment the digit to
                the
                left of the current one.</p>
            <p>In this case, the rightmost digit of &quot;09&quot; was at its maximum value, so we reset it to a
                &quot;0&quot; and incremented the digit to the left of it from &quot;0&quot; to &quot;1&quot;,
                resulting in &quot;10&quot;.</p>
            <p>When incrementing, we treat the number as if there is are infinite zeros to the left of it. These
                don&#39;t
                change the value of the number, so they are usually omitted in the written representation of the number.
            </p>
            <p>So now that we know the rules behind decimal, let&#39;s apply it to binary!</p>
            <p>Again, let&#39;s start by counting up from zero (but this time, in binary):</p>
            <p>0, 1, ?</p>
            <p>Our rightmost digit is at its maximum value, so let&#39;s increment the digit to the left of it and reset
                the
                current digit&#39;s value. Remember how we assume there are infinite zeros to the left of the number.
            </p>
            <p>The rightmost &quot;1&quot; becomes &quot;0&quot;, and the implicit &quot;0&quot; to the left of it
                becomes
                &quot;1&quot;, resulting in the binary number &quot;10&quot;.</p>
            <p>Counting further, we get:</p>
            <p>11, 100, 101, 111, etc.</p>
            <p>So now that we have the rules for counting in binary, let&#39;s try to mathematically represent it.</p>
        </div>
    </div>

    <!-- Positional number systems -->
    <div class="chunk">
        <label for="3">
            <h1>Positional number systems</h1>
        </label>
        <input id="3" type="checkbox">

        <div class="content">

            <p>Remember place values?</p>
            <p>Place values are the &quot;weighting&quot; of each digit within a number. Using place values and a some
                arithmetic, you can easily determine the value of a number. If you remember back from second grade, each
                decimal digit&#39;s value is ten times more than the one to the right of it, with the rightmost number
                having a place value of one, like this:</p>
            <figure>
                <table>
                    <thead>
                        <tr>
                            <th>Digit</th>
                            <th>3</th>
                            <th>2</th>
                            <th>1</th>
                            <th>2</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Place Value</td>
                            <td>1000</td>
                            <td>100</td>
                            <td>10</td>
                            <td>1</td>
                        </tr>
                    </tbody>
                </table>
            </figure>
            <p>You could find the value of the number by summing the digits multiplied by their respective place values.
                Take the example from above:</p>
            <figure>
                <table>
                    <thead>
                        <tr>
                            <th>Digit</th>
                            <th>3</th>
                            <th>2</th>
                            <th>1</th>
                            <th>2</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Place Value</td>
                            <td>1000</td>
                            <td>100</td>
                            <td>10</td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td>Real Value</td>
                            <td>3 * 1000 = 3000</td>
                            <td>2 * 100 = 200</td>
                            <td>1 * 10 = 10</td>
                            <td>2 * 1 = 2</td>
                        </tr>
                    </tbody>
                </table>
            </figure>
            <p>Which has a value of 3212, which is 3000 + 200 + 10 + 1.</p>
            <p>So using that representation, let’s try to figure out a general form of positional numbering systems.</p>
            <p>Let’s start by writing the place values like this:</p>
            <figure>
                <table>
                    <thead>
                        <tr>
                            <th>Digit</th>
                            <th>3</th>
                            <th>2</th>
                            <th>1</th>
                            <th>2</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Place Value</td>
                            <td>10<sup>3</sup></td>
                            <td>10<sup>2</sup></td>
                            <td>10<sup>1</sup></td>
                            <td>10<sup>0</sup></td>
                        </tr>
                    </tbody>
                </table>
            </figure>
            <p>Do you see anything interesting about this representation of place value? </p>
            <p>Decimal is a base <em>ten</em> system, which means that all the place values are powers of ten.</p>
            <p>Let’s look at a binary number’s place values:</p>
            <figure>
                <table>
                    <thead>
                        <tr>
                            <th>Digit</th>
                            <th>1</th>
                            <th>0</th>
                            <th>1</th>
                            <th>1</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Place Value</td>
                            <td>2<sup>3</sup></td>
                            <td>2<sup>2</sup></td>
                            <td>2<sup>1</sup></td>
                            <td>2<sup>0</sup></td>
                        </tr>
                    </tbody>
                </table>
            </figure>
            <p>Here’s the common thread: for a base-<em>n</em> number system, a digit in position <em>p</em> (defined as
                the
                number of digits in between it and the rightmost number) will have a place value of n<sup>p</sup></p>
            <p>To calculate the value of any number in any positional numbering system, sum the digits’ values
                multiplied by
                their respective place values.</p>
        </div>
    </div>

    <div class="chunk hr">
        <h1>Building binary intuition</h1>
    </div>

    <!-- Bitfield Basics -->
    <div class="chunk">
        <h1>Bitfield basics</h1>
        <div class="content">

            <fieldset class="bitfield" bits=8>
                <div style="margin-right: 12px;">This is a bitfield! =></div>
            </fieldset>
            <p>It is an intuitive representation of a binary number, where each checkbox represents a single bit.</p>
            <p>If you hover over the bitfield, you&#39;ll see the place value of each bit.</p>
            <p>To the right of all the checkboxes is the decimal value of the binary number.</p>
            <p>Although the bitfield above is <strong>eight bits</strong>, bitfields can be of all sizes!</p>
            <fieldset class="bitfield" bits=4 value=12>
                <div style="margin-right: 12px;">4 bits =></div>
            </fieldset><br>
            <fieldset class="bitfield" bits=16 value=1234>
                <div style="margin-right: 12px;">16 bits =></div>
            </fieldset><br>
            <fieldset class="bitfield" bits=24>
                <div style="margin-right: 12px;">24 bits =></div>
            </fieldset>
            <p>
                (They get a lot more unwieldy as they get bigger)
            </p>
        </div>
    </div>

    <!-- Messing with Bitfields -->
    <div class="chunk">
        <h1>Messing with Bitfields</h1>
        <div class="icon cross" id="p0-c0"></div>

        <div class="content">
            <p>Here's an enabled bitfield for you to mess with.</p>
            <fieldset id="p0-bf0" class="bitfield" bits=4></fieldset>
            <p>For this first exercise, try to set the bitfield's value to five.</p>
            <div class="hint" hint="
        Check the boxes so that their place values sum to five.
        ">
                Hint 1
            </div>
            <div class="hint" hint="
        Check the checkboxes with the place values &quot;1&quot; and &quot;4&quot;. Since 1 + 4
        = 5, this is the solution!
        ">
                Solution
            </div>

            <script>
                const p0bf0 = document.getElementById("p0-bf0");
                const p0c0 = document.getElementById("p0-c0");

                p0bf0.addEventListener("valuechange", (ev) => {
                    setTimeout(() => {
                        const newValue = ev.detail;
                        if (newValue === 5) {
                            p0c0.classList.remove("cross");
                            p0c0.classList.add("check");
                            alert("You got it! Good job!")
                        }
                    }, 50);
                });
            </script>
        </div>
    </div>

    <!-- Advanced Bitfield Usage -->
    <div class="chunk">
        <h1>Advanced bitfield usage</h1>

        <div class="content">
            <fieldset class="bitfield" bits=8 value=1></fieldset>

            <p>
                Bitfields have some extra controls, for ease of use:
            <ol>
                <li>You can double click the bitfield to set its value directly. Try it!</li>
                <li>
                    Click and drag the bitfield's checkboxes left and right to
                    shift the bits left or right.
                </li>
            </ol>

            </p>
        </div>
    </div>

    <!-- Digit shifting -->
    <div class="chunk">
        <label for="4">
            <h1>Digit shifting</h1>
        </label>
        <input id="4" type="checkbox">

        <div class="content">
            <p>When you were shifting the bits around in the activity above, did you notice anything interesting about
                the way the number’s value changed?</p>
            <p>You may have noticed that every time you shift the bits left, the value doubles, and every time you shift
                the bits right, the value halves.</p>
            <p>Why is this?</p>
            <p>Well, let’s see what this digit shifting operation does to a decimal number.</p>
            <p>For example, &quot;13&quot; shifted to the left is &quot;130&quot;. This means that a left shift
                multiplies the number’s value by a factor of ten. Let’s shift &quot;13&quot; to the right. This results
                in &quot;1&quot;, since the rightmost digit is discarded. Therefore, a right shift is equivalent to
                dividing by ten and rounding down.</p>
            <p>When we write this out, a digit shift essentially increments or decrements the place value’s power in
                each digit.</p>
            <p><strong>Before shift</strong></p>
            <figure>
                <table>
                    <thead>
                        <tr>
                            <th>Digit</th>
                            <th>1</th>
                            <th>3</th>
                            <th>0*</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Place Value</td>
                            <td>10<sup>1</sup></td>
                            <td>10<sup>0</sup></td>
                            <td>10<sup>-1</sup></td>
                        </tr>
                        <tr>
                            <td>Real Value</td>
                            <td>1 * 10 = 10</td>
                            <td>3 * 1 = 3</td>
                            <td>0 * 0.1 = 0</td>
                        </tr>
                    </tbody>
                </table>
            </figure>
            <p>*Since &quot;0&quot; has a fractional place value, we omit this from the actual number’s representation.
            </p>
            <p>10 + 3 + 0 = <strong>13</strong></p>
            <p><strong>After left shift</strong></p>
            <figure>
                <table>
                    <thead>
                        <tr>
                            <th>Digit</th>
                            <th>1</th>
                            <th>3</th>
                            <th>0</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Place Value</td>
                            <td>10<sup>1+1</sup></td>
                            <td>10<sup>0+1</sup></td>
                            <td>10<sup>-1+1</sup></td>
                        </tr>
                        <tr>
                            <td>Real Value</td>
                            <td>1 * 100 = 100</td>
                            <td>3 * 10 = 30</td>
                            <td>2 * 1 = 0</td>
                        </tr>
                    </tbody>
                </table>
            </figure>
            <p>100 + 30 + 0 = <strong>130</strong></p>
            <p>This is an extremely useful property of decimal.</p>
            <p>You’ve probably used digit shifting in your daily life to speed up math without even knowing it. When
                multiplying by a power of ten, it’s easier to just shift the digits left as opposed to multiplying it
                all out. The same goes for division by a power of ten. We can simply shift the digits right instead. So,
                if a base <em>ten</em> digit shift multiplies or divides a number’s value by a power of <em>ten</em>,
                what would a base <em>two</em> bit shift do?</p>
            <p>If you guessed that it multiplies or divides by a power of <em>two</em>, you’d be right.</p>
            <p>You can see this happening in front of your eyes by dragging the bitfield horizontally and observing the
                value.</p>
        </div>
    </div>

    <!-- Messing with left shifts -->
    <div class="chunk">
        <h1>Messing with left shifts</h1>
        <div class="icon cross" id="p1-c0"></div>

        <div class="content">

            <fieldset id="p1-bf0" class="bitfield" bits=8 value=25></fieldset>
            <p>For this exercise, try to set the bitfield's value to 100 without toggling any bits.</p>
            <div class="hint" hint="
        Drag the bits left 2 places. 25 * (2 ^ 2) = 100
        ">
                Solution
            </div>

            <script>
                const p1bf0 = document.getElementById("p1-bf0");
                const p1c0 = document.getElementById("p1-c0");

                p1bf0.addEventListener("valuechange", (ev) => {
                    setTimeout(() => {
                        const newValue = ev.detail;
                        if (newValue === 100) {
                            p1c0.classList.remove("cross");
                            p1c0.classList.add("check");
                            alert("You got it! Good job!")
                        }
                    }, 50);
                });
            </script>
        </div>
    </div>

    <!-- Messing with right shifts -->
    <div class="chunk">
        <h1>Messing with right shifts</h1>
        <div class="icon cross" id="p2-c0"></div>

        <div class="content">

            <fieldset id="p2-bf0" class="bitfield" bits=8 value=51></fieldset>
            <p>For this exercise, try to set the bitfield's value to 6 without toggling any bits.</p>
            <div class="hint" hint="
        Remember that a right shift rounds down
        ">
                Hint 1
            </div>
            <div class="hint" hint="
        Drag the bits right 3 places. floor(51 / (2 ^ 3)) = 6
        ">
                Solution
            </div>

            <script>
                const p2bf0 = document.getElementById("p2-bf0");
                const p2c0 = document.getElementById("p2-c0");

                p2bf0.addEventListener("valuechange", (ev) => {
                    setTimeout(() => {
                        const newValue = ev.detail;
                        if (newValue === 6) {
                            p2c0.classList.remove("cross");
                            p2c0.classList.add("check");
                            alert("You got it! Good job!")
                        }
                    }, 50);
                });
            </script>
        </div>
    </div>

    <!-- Putting it all together: The multiply shift -->
    <div class="chunk">
        <label for="5">
            <h1>Putting it all together: The multiply shift</h1>
        </label>
        <input id="5" type="checkbox">

        <div class="content">
            <h2>What is it?</h2>
            <p>The multiply shift is an elegant way to multiply a binary number by a constant fractional value without
                using floating point math.</p>
            <h2>Why hack bits?</h2>
            <p>In computers, floating-point numbers are a binary format for holding real values using scientific
                notation. The main gripe with floating point that many computer programmers have is that it is extremely
                slow to do arithmetic with when compared to integers. Without a dedicated piece of hardware for it,
                floating point math is often tens of times slower than integer math, which is why I– among many other
                people– avoid it like the plague.</p>
            <p>The multiply shift is over twice as fast compared to just using raw floating point, which makes it a
                useful tool in computationally constrained environments. Keep in mind that the speed figure was computed
                on a system that has dedicated hardware for speeding up floating-point math. If my computer didn’t have
                that, the speedup would’ve been even more drastic.</p>
            <h2>How does it work?</h2>
            <p>The multiply shift works like this:</p>
            <ol>
                <li>Multiply a number by a constant value</li>
                <li>Shift it right by a constant value</li>

            </ol>
            <p>Conceptually, it’s very simple, but there’s a lot of cool math behind it.</p>
            <p>Let’s first turn it into a mathematical expression:</p>
            <p>n * (m / 2<sup>s</sup>)</p>
            <p>Where <em>n</em> is one multiplicand, <em>m</em> is the an integer scaling value and <em>s</em> is the
                right shift value.</p>
            <p>Essentially, we are multiplying <em>n</em> by a fraction with a positive integral numerator and
                denominator that is a power of two.</p>
            <p>This means that the multiply shift is simply an approximation for a fraction.</p>
            <p>Once we convert our target number into a fraction, we can determine its multiply shift. For example,
                let’s try to use this to convert from degrees Celsius to degrees Fahrenheit. The equation is as follows:
            </p>
            <p>(C * 9 / 5) + 32 = F</p>
            <p>As you can see, there’s a fraction within the equation. We want our multiply shift approximation to be as
                close as possible to that. So, let’s set up the equation:</p>
            <p>9 / 5 = m / 2<sup>s</sup></p>
            <p>Since we have two variables, we can’t solve for it yet.</p>
            <p>I’m going to randomly set <em>s</em> to eight. I chose this because shift value determines how many
                useful bits the result will have. Since we are using 32-bit numbers, shifting right 8 bits will leave us
                with 24 usable bits (since shifting right discards bits). This introduces a trade-off. As <em>s</em>
                gets higher, the approximation becomes more accurate. However, you have a lesser range of values to work
                with. When making your own implementations, just use common sense to choose a value for <em>s</em>.</p>
            <p>m / 2<sup>8</sup> = 9 / 5</p>
            <p><del>2<sup>8</sup></del> * m / <del>2<sup>8</sup></del> = 2<sup>8</sup> * (9 / 5) </p>
            <p>m = <strong>461</strong></p>
            <p>So that means our multiply shift fraction is now equivalent to:</p>
            <p>461 / 256 = 1.80078125</p>
            <p>Which is pretty close to 9 / 5 (1.8)</p>
            <p>With those numbers calculated, we can now substitute it all in to get the equation:</p>
            <p>(C * 461) &gt;&gt; 8 + 32 = F</p>
            <p>Where &quot;&gt;&gt;&quot; is the right shift operator.</p>
            <p>On my machine, the multiply-shift version is over <em>three times faster</em> than the floating-point
                equation!</p>
            <p>The multiply shift is one of many tools that can be used to speed up calculations on a computer.
                Hopefully, you understood the math and found it beautiful. It’s one of my favorite bit tricks.</p>
            <p>Thank you for reading, I hope you had fun!</p>
            <p>(I know I did ;D)</p>
        </div>
    </div>


    <script>
        // apply BinaryShifter to all bitfields
        [...document.getElementsByClassName("bitfield")].forEach(BinaryShifter.applyTo);
    </script>
</body>

</html>